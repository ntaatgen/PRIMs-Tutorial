// More general version of count

define task count {
  initial-skills: (count)
  default-activation: 1.0 // All chunks defined in this model receive a fixed baselevel activation of 1.0
  ol: t
  rt: -2.0
  lf: 0.2
  default-operator-self-assoc: 0.0
  egs: 0.05
  retrieval-reinforces: t
  bindings-in-dm: t
}

define skill count {
	operator set-instruction {
		G1 = count
	==>
		count-fact -> *fact-type
		say -> *action
		say -> *respond-action
		stop -> *success-arg
		iterate -> *next-skill
		respond -> *final-action-skill
		read -> G1
	}
}


define skill read {
	operator read-for-two-items {
		V1 <> nil
		V2 <> nil
		WM1 = nil
	==>
		V1 -> WM1
		V2 -> WM2
	}
	operator switch-to-next-skill {
		V1 = WM1
	==>
		*next-skill -> G1
	}
}

define skill iterate {
//  Start iteration
  operator start-iteration {
   WM3 = nil  // Slot we use for iterator is empty
  ==>
   WM1 -> WM3 
   *fact-type -> RT1 
   WM1 -> RT2
   *action -> AC1 
   WM1 -> AC2
   }

//    Iterate as long WM2 does not match the final goal
  operator iterate {
    RT2 = WM3
    WM2 <> WM3
   ==>
    RT3 -> WM3
    *fact-type -> RT1
    RT3 -> RT2
    *action -> AC1
    RT3 ->AC2
  }

//    Stop when reaching final match
  operator final {
    WM2 = WM3
   ==>
    *final-action-skill -> G1
	*success-arg -> *respond-arg
  }

// If the iteration fails, do the final-action on final-response-negative
  operator final-fail {
  	WM2 <> WM3
  	RT1 = error
  	==>
  	*final-action-skill -> G1
	*failure-arg -> *respond-arg
	}
}

define skill respond {
	operator carry-out-action {
		G1 <> nil // Operators require at least one condition
		==>
		*respond-action -> AC1
		*respond-arg -> AC2
		nil -> G1
	}
}

define facts {
    (cf1 count-fact  one  two)
    (cf2 count-fact  two  three)
    (cf3 count-fact  three  four)
    (cf4 count-fact  four  five)
    (cf5 count-fact  five  six)
    (cf6 count-fact six seven)
    (cf7 count-fact seven eight)
    (cf8 count-fact eight nine)
    (cg9 count-fact nine ten)
}

define action say {
  latency: 0.3
  noise: 0.1
  distribution: uniform
  output: Saying
}

define script {
    digits = ["one","two","three","four","five","six","seven",
        "eight","nine","ten"]
    start = random(3)
    end = start + 1 + random(3)
    print("Counting from",digits[start],"to",digits[end])
    screen(digits[start],digits[end])
    run-until-action("say","stop")
    issue-reward()
    trial-end()
}
